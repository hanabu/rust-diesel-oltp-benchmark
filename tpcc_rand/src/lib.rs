use rand::Rng;

pub struct TpcRandom(rand::rngs::ThreadRng);

impl TpcRandom {
    /// New random number generator
    pub fn new() -> Self {
        Self(rand::thread_rng())
    }

    fn alnum_bytes(&mut self, len: usize) -> Vec<u8> {
        const CHARS: [u8; 62] = [
            b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h', b'i', b'j', b'k', b'l', b'm', b'n',
            b'o', b'p', b'q', b'r', b's', b't', b'u', b'v', b'w', b'x', b'y', b'z', b'A', b'B',
            b'C', b'D', b'E', b'F', b'G', b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O', b'P',
            b'Q', b'R', b'S', b'T', b'U', b'V', b'W', b'X', b'Y', b'Z', b'0', b'1', b'2', b'3',
            b'4', b'5', b'6', b'7', b'8', b'9',
        ];

        // Select CHARS in random
        let bytes = (0..len)
            .map(|_| {
                let r = self.0.gen_range(0..CHARS.len());
                CHARS[r]
            })
            .collect::<Vec<u8>>();
        bytes
    }

    /// TPC-C standard spec. 4.3.2.2
    /// The character set used must include at least 26 lower case letters,
    ///   26 upper case letters, and the digits 0 to 9
    pub fn alnum_string(&mut self, len: std::ops::RangeInclusive<usize>) -> String {
        // Random length
        let len = self.0.gen_range((*len.start())..=(*len.end()));
        // Random chars
        let bytes = self.alnum_bytes(len);

        // bytes contains only CHARS[] byte, so unwrap() is safe
        String::from_utf8(bytes).unwrap()
    }

    /// Phone number
    pub fn num_string(&mut self, len: usize) -> String {
        const CHARS: [u8; 10] = [b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9'];

        // Select CHARS in random
        let bytes = (0..len)
            .map(|_| {
                let r = self.0.gen_range(0..CHARS.len());
                CHARS[r]
            })
            .collect::<Vec<u8>>();

        // bytes contains only CHARS[] byte, so unwrap() is safe
        String::from_utf8(bytes).unwrap()
    }

    /// Uniformly distributed i32 value in range
    pub fn i32_range(&mut self, range: std::ops::RangeInclusive<i32>) -> i32 {
        self.0.gen_range(range)
    }

    pub fn non_uniform_i32(&mut self, mask: i32, range: std::ops::RangeInclusive<i32>) -> i32 {
        const RUNTIME_CONST_C: i32 = 100;
        let r = (self.0.gen_range(0..=mask) | self.0.gen_range(range.clone())) + RUNTIME_CONST_C;
        let w = range.end() - range.start() + 1;
        r % w + range.start()
    }

    /// Uniformly distributed f64 value in range
    pub fn f64_range(&mut self, range: std::ops::RangeInclusive<f64>) -> f64 {
        self.0.gen_range(range)
    }

    /// TPC-C standard spec. 4.3.2.7
    /// zip code must be generated by the concatenation of:
    ///    1. A random n-string of 4 numbers, and
    ///    2. The constant string '11111'.
    pub fn zip_code(&mut self) -> String {
        format!("{:04}11111", self.0.gen_range(0..=9999))
    }

    /// items.i_data, 10% contains "ORIGINAL"
    pub fn item_data(&mut self) -> String {
        // Random length
        let len = self.0.gen_range(26..=50);

        let bytes = if 0 == self.0.gen_range(0..=9) {
            // Insert ORIGINAL
            let pos = self.0.gen_range(0..=(len - 8));
            let mut bytes1 = self.alnum_bytes(pos as usize);
            let bytes2 = self.alnum_bytes((len - pos - 8) as usize);

            bytes1.extend_from_slice(b"ORIGINAL");
            bytes1.extend_from_slice(&bytes2);
            bytes1
        } else {
            // Random chars only
            self.alnum_bytes(len as usize)
        };

        String::from_utf8(bytes).unwrap()
    }

    /// TPC-C standard spec. 4.3.2.3
    /// Customer last name (c_last)
    pub fn last_name(index: i32) -> String {
        const PARTS: [&str; 10] = [
            "BAR", "OUGHT", "ABLE", "PRI", "PRES", "ESE", "ANTI", "CALLY", "ATION", "EING",
        ];

        let mut index = index as usize;
        let i1 = index % 10; // digit of 1
        index /= 10;
        let i10 = index % 10; // digit of 10
        index /= 10;
        let i100 = index % 10; // digit of 100

        vec![PARTS[i100], PARTS[i10], PARTS[i1]].concat()
    }
}
